import numpy as np

def noisy_walker_v5b(initial_leg_attach, initial_leg_pos, leg_state, action, cell_position, cell_orientation, 
                           eta, spring_constant, cirrus_force, detachment_length, forceX, forceY):
    """
    Performs a single iteration of the noisy walker model.

    Parameters:
        initial_leg_location (list of tuples): (x, y) positions of each leg.
        leg_state (list): Motion states of legs (0 = attached, 1 = moving).
        action (int): Index of the leg to move.
        cell_position (tuple): (x, y) position of the cell.
        cell_orientation (float): Orientation of the cell.
        eta (float): Viscous drag coefficient.
        spring_constant (float): Elastic constant of the cirri.
        cirrus_force (float): Force generated by cirri.
        detachment_length (float): Maximum length before a cirrus detaches.

    Returns:
        new_leg_location (list of tuples): Updated (x, y) positions of each leg.
        new_leg_state (list): Updated motion states of the legs.
        new_cell_position (tuple): Updated (x, y) position of the cell.
        new_cell_orientation (float): Updated cell orientation.
        displacement_x (float): Distance traveled in the x direction.
        displacement_y (float): Distance traveled in the y direction.
    """
    num_legs = len(initial_leg_pos)
    xpos, ypos = zip(*initial_leg_pos)  # Extract x, y positions separately
    xpos, ypos = np.array(xpos), np.array(ypos)
    xattach, yattach = zip(*initial_leg_attach)
    xattach, yattach = np.array(xattach), np.array(yattach)

    # Compute max distance (longest linear dimension of the cell)
    max_distance = max(np.sqrt((xpos[i] - xpos[j]) ** 2 + (ypos[i] - ypos[j]) ** 2) 
                       for i in range(num_legs) for j in range(num_legs))

    # Compute net force and torque
    force_sum_x, force_sum_y, torque_sum = 0, 0, 0
    for i in range(num_legs):
        force_sum_x += forceX[i]
        force_sum_y += forceY[i]
        position_vector_x, position_vector_y = xpos[i] - cell_position[0], ypos[i] - cell_position[1]
        torque_sum += position_vector_x * forceY[i] - position_vector_y * forceX[i]

    # Compute rigid-body translations
    displacement_x, displacement_y = force_sum_x / eta, force_sum_y / eta
    new_cell_position = (cell_position[0] + displacement_x, cell_position[1] + displacement_y)

    # Update leg positions
    xpos += displacement_x
    ypos += displacement_y
    for i in range(num_legs):
        if leg_state[i] == 1:  # Move detached cirri
            xattach[i] += displacement_x
            yattach[i] += displacement_y

    # Compute rigid-body rotation
    eta_rotation = 0.5 * eta * (max_distance ** 2)
    angular_displacement = torque_sum / eta_rotation
    new_cell_orientation = (cell_orientation + angular_displacement) % (2 * np.pi)

    # Apply rotation to cirri
    for i in range(num_legs):
        pos_x, pos_y = xpos[i] - new_cell_position[0], ypos[i] - new_cell_position[1]
        xpos[i] = new_cell_position[0] + (pos_x * np.cos(angular_displacement) - pos_y * np.sin(angular_displacement))
        ypos[i] = new_cell_position[1] + (pos_x * np.sin(angular_displacement) + pos_y * np.cos(angular_displacement))

        if leg_state[i] == 1:  # Apply rotation to substrate attachment points
            pos_x, pos_y = xattach[i] - new_cell_position[0], yattach[i] - new_cell_position[1]
            xattach[i] = new_cell_position[0] + (pos_x * np.cos(angular_displacement) - pos_y * np.sin(angular_displacement))
            yattach[i] = new_cell_position[1] + (pos_x * np.sin(angular_displacement) + pos_y * np.cos(angular_displacement))

    # Calculate forces for each cirrus
    for i in range(num_legs):
        if leg_state[i] == 0:  # Attached cirri
            cirrus_length = np.sqrt((xpos[i] - xattach[i]) ** 2 + (ypos[i] - yattach[i]) ** 2)
            if cirrus_length > 0:
                stretch_force = spring_constant * cirrus_length
                unit_x = (xattach[i] - xpos[i]) / cirrus_length
                unit_y = (yattach[i] - ypos[i]) / cirrus_length
                forceX[i] = stretch_force * unit_x
                forceY[i] = stretch_force * unit_y
            else:
                forceX[i] = 0
                forceY[i] = 0
        else:
            forceX[i] = cirrus_force * np.cos(new_cell_orientation)
            forceY[i] = cirrus_force * np.sin(new_cell_orientation)
    
    # Update leg motion state based on action
    new_leg_state = leg_state.copy()
    if action is not None:
        if leg_state[action] == 1:
            new_leg_state[action] = 0
            xattach[action] = xpos[action]
            yattach[action] = ypos[action]
        elif leg_state[action] == 0:
            new_leg_state[action] = 1
            xattach[action] = xpos[action]
            yattach[action] = ypos[action]

        # Check for detachment due to excessive stretch
        cirrus_length = np.linalg.norm([xpos[action] - xattach[action], ypos[action] - yattach[action]])
        if new_leg_state[action] == 0 and cirrus_length > detachment_length:
            new_leg_state[action] = 1
            xattach[action] = xpos[action]
            yattach[action] = ypos[action]

    new_attach = list(zip(xattach, yattach))
    new_pos = list(zip(xpos, ypos))

    return new_attach, new_pos, new_leg_state, new_cell_position, new_cell_orientation, forceX, forceY
