function [cellxrecord, cellyrecord] = noisy_walker_v5a(infile, eta, spring_constant, cirrus_force, detachment_length, P10, P01, iterations, verbose, stateVector, legsToMoveVector)

% modified to read gait patterns 
% (real data, shuffled, or simulated according to rule)
% allows us to perform same analyses for gait state transitions
% also changed rotation viscosity

% modified to read in a file specifying location of the cirri
% each cirrus is specified as follows:


%  {cirrus_ID [x,y] }

% noisy_walker_v4('cirrus_testfile_asymmetric.txt', 20, 2.0, 1, 0.5, 0.2, 0.1, 10000,1)


% modified to add a flag to suppress outputs so that it can be called
% within a parameter sweep loop
% if verbose == 1 then it gives outputs
% if verbose == 0 then no outputs

% version 2 adds some analysis of motion states and also keeps track of
% time since last state transition to allow for more complex time series
% models

%noisy_walker_v2(3, 3, 20, 2.0, 2, 1.0, 0.2, 0.1, 4000)

% program to simulate stochastic gait of a Euplotes-like walker
% models the cell as an array of cirri on a square lattice
% each cirrus can be in either of two mutually exclusive motion states
% state 1 - cirrus is moving and generating forward propulsive force
% state 0 - cirrus is not moving but is attached by its tip to the
% substrate.   in state 2, as the cirrus becomes stretched it acts like a
% Hookean spring and exerts a force directed towards its point of
% attachment.
% while in state 0, if the cirrus stretches beyond a critical length, it
% will detach and switch to state 1.

% input parameters
% xsize, ysize - the width and length in units of cells of the
% rectangular array  (this model assumes the cell is a rectangle)

% eta - frictional coefficient so including viscosity but also cell
% size and shape - its really just an adjustable parameter

% spring_constant - yields force generation by attached cirri as they are
% stretched out from the point of attachment

% cirrus_force - magnitude of force generated by moving cirri.  
% all forces of moving cirri are taken as parallel with the cells central
% axis

% detachment length - length beyond which an attached cirrus will detach
% from the substrate

% P10 - the probability of switching from state 1 (moving, not attached)
% to state 0 (not moving, attached)


% P01 - the probability of switching from state zero (not moving,
% attached) to state 1 (moving, not attached)

% iterations - number of steps of the simulation to be run
% iterations = max(size(stateVector));

% sample call
% noisy_walker_v1(3, 3, 20, 0.1, 1, 2.0, 0.8, 0.1, 500)



% version 1 simplifying assumptions:
% initial veresion assume switching between states is completely a Poisson
% process 
% also for initial version assume that every grid unit has a cirrus on it



% set up arrays to hole information about the cirri


fid = fopen(infile);

numlines = 0;
big_string = '';


% read the whole file in as one huge string
tline = fgetl(fid); % read line and remove newline
while ischar(tline)
    %disp(tline)
    if ~strncmp(tline, '%', 2) % skip any comment lines
      numlines = numlines + 1;
      big_string = strcat(big_string, ' ', tline);
    end

    
    tline = fgets(fid);
end

disp(big_string);


num_cirri = length(regexp (big_string, '{'));

% pad any non-space delimiters so that when we split the string into tokens
% based on spaces, everything gets split
big_string = regexprep(big_string, '{', ' { ');
big_string = regexprep(big_string, '}', ' } ');
big_string = regexprep(big_string, '[', ' [ ');
big_string = regexprep(big_string, ']', ' ] ');
big_string = regexprep(big_string, ',', ' , ');

% now trim out any multiple white spaces otherwise we end up with tokens
% that are just a string of spaces
big_string = regexprep(big_string, '\s+', ' ');


input_words = regexp(big_string, ' ', 'split');

num_words = length(input_words);

current_cirrus_ID = 0;
for i=1:num_words
    %disp(input_words(i));
    
        if strncmp(input_words(i), '{', 1)
            current_cirrus_ID = current_cirrus_ID + 1;  % create a new ID for each new cirrus when defined
            cirrus_name(current_cirrus_ID) = input_words(i+1);
        elseif strncmp(input_words(i), '[', 1)
            number_string1 = char(input_words(i+1)); % convert from cell to character string
            number_string2 = char(input_words(i+3));
            
            xpos(current_cirrus_ID) = sscanf(number_string1, '%f');
            ypos(current_cirrus_ID) = sscanf(number_string2, '%f');
            
        end
        
 
end % loop over num_words

assignin('base','cirriPos',[xpos',ypos']);

num_cirri = current_cirrus_ID

disp('name   xpos    ypos');
for i=1:num_cirri
    X = sprintf('cirrus %s coordinates %d, %d ',cirrus_name{i},xpos(i), ypos(i));
    disp(X);
    %disp([cirrus_name(i), '     ', num2str(xpos(i)), '      ', num2str(ypos(i))]);
end




% calculate longest linear dimension of cell based on largest distance
% between pairs of cirri, we need this later to convert eta into rotational
% friction coefficient
max_distance = 0;
for i=1:num_cirri
    for j=1:num_cirri
        distance = sqrt((xpos(i) - xpos(j))^2 + (ypos(i) - ypos(j))^2 );
        if distance > max_distance
            max_distance = distance
        end
    end
end

xsum = 0;
ysum = 0;
for i=1:num_cirri
    xsum = xsum + xpos(i);
    ysum = ysum + ypos(i);
end
x_centroid = xsum/num_cirri;
y_centroid = ysum/num_cirri;

directions = zeros(iterations); % record of cell direction
cellxrecord = zeros(iterations);
cellyrecord = zeros(iterations);
motion_state_record = zeros(num_cirri, iterations);
state_sum = zeros(iterations); % basically an order parameter
total_detachments = 0;  % how often the cell completely is in motion state 1

%xpos = zeros(xsize,ysize);  % coordinates of the base of each cirrus
%ypos = zeros(xsize,ysize);

xattach = zeros(num_cirri); % coordinates of substrate attachment site for each cirrus
yattach = zeros(num_cirri);

cirrus_lengths = zeros(num_cirri); % stretched lenngth of each cirrus

motionstate = zeros(num_cirri); % current motion state
                                    % 0 = attached not moving
                                    % 1 = moving
last_transition = zeros(num_cirri); % stores the iteration number at which the state last changed
                                     % in order to be able to implement
                                     % gamma distributed wait times, etc.
                                    
forceX = zeros(num_cirri); % components of force generation by each unit
forceY = zeros(num_cirri);  % forces given in the lab frame


% set up initial condition of the cell completely at rest and every cirrus
% attached, with cell located at the origin

cell_direction = 0; % angle of cell long axis relative to lab frame
cell_position_x = x_centroid;  % coordinates of cell center in lab frame
cell_position_y = y_centroid;
for i=1:num_cirri
        xattach(i) = xpos(i); % initialize attached right underneath
        yattach(i) = ypos(i);
        cirrus_lengths(i) = 0;
        motionstate(i) = 0;
        forceX(i) = 0;
        forceY(i) = 0;
end

% keep track of how many 0 -> 1 transitions are mechanically induced
release_spontaneous = 0;
release_pulling = 0;
total_motion = 0;  % keep track of how much total motion


for current_iteration=1:iterations
    
    if verbose == 1
    running_iteration = current_iteration
    end
    
    % save a record of the current state for plotting later
    directions(current_iteration) = cell_direction;
    cellxrecord(current_iteration) = cell_position_x;
    cellyrecord(current_iteration) = cell_position_y;

    sum_states = 0;
    for i=1:num_cirri
    
        motion_state_record(i, current_iteration) = motionstate(i);
        sum_states = sum_states + motionstate(i);
    end
    state_sum(current_iteration) = sum_states;
    if sum_states == num_cirri
        total_detachments = total_detachments + 1;
    end

    
    % calculate the rigid-body force acting on the cell as a whole
    % based on the forces acting on each cirrus at the start of iteration 
    force_sum_x = 0; % update translation
    force_sum_y = 0;
    torque_sum = 0;
    for i=1:num_cirri
           
        % calculate sum of forces driving translational motion
        force_sum_x = force_sum_x + forceX(i);
        force_sum_y = force_sum_y + forceY(i);
        
        % calculate sum of torques driving rotational motion
        position_vector_x = xpos(i) - cell_position_x; % cellpos is the cell center
        position_vector_y = ypos(i) - cell_position_y;
        cross_product = position_vector_x*forceY(i) - position_vector_y*forceX(i);
        torque_sum = torque_sum + cross_product;
   
    end
    
    
    
    % apply the rigid body motions to all the cirri and to the cell
    % do all the translations first
    % calculate displacements assuming force resisted by viscosity
    % eta actually includes both the viscosity and also the time scale
    % but for us its just a parameter that we can adjust
    displacement_x = force_sum_x / eta;
    displacement_y = force_sum_y / eta;
    cell_position_x = cell_position_x + displacement_x;
    cell_position_y = cell_position_y + displacement_y;
    total_motion = total_motion + sqrt(displacement_x^2 + displacement_y^2);
    for i=1:num_cirri
    
        if motionstate(i) == 1 % only update attachment point if not already attached
            xattach(i) = xattach(i) + displacement_x; % update substrate attachment points
            yattach(i) = yattach(i) + displacement_y;
        end
        xpos(i) = xpos(i) + displacement_x;   % update base of cirrus
        ypos(i) = ypos(i) + displacement_y;
    
    end
    
    % now do all the rotations
    % calculate the rotation matrix assuming torque resisted by viscosity
    eta_rotation = 0.5 * eta * (max_distance^2); %since eta has units of 
                                    % Ns/m since it converts a velocity to 
                                    % a force but now we need a frictional
                                    % coefficient that converts an angular
                                    % velocity (units 1/s) to a torque
                                    % (units Nm).   so the conversion
                                    % factor nees to have units of m^2.
                                    % **New prefactor** for this version
                                    % makes cell appropriately unsteady.
    angular_displacement = torque_sum / eta_rotation;
    cell_direction = cell_direction + angular_displacement;     
    if cell_direction > 2*pi
        cell_direction = cell_direction - 2*pi;
    end
    if cell_direction < -2*pi
        cell_direction = 2*pi + cell_direction;
    end
    for i=1:num_cirri
    
        % will need to apply rotation about the cell center as reference
        % apply rotation to the base of cirrus position
        position_x = xpos(i) - cell_position_x; % position relative to cell center
        position_y = ypos(i) - cell_position_y;
        % multiply position vector by rotation matrix
        new_x = position_x*cos(angular_displacement) - position_y*sin(angular_displacement);
        new_y = position_x*sin(angular_displacement) + position_y*cos(angular_displacement);
        xpos(i) = new_x + cell_position_x;
        ypos(i) = new_y + cell_position_y;
        
        % apply rotation to substrate attachment point
        if motionstate(i) == 1 % only update if not attached
            position_x = xattach(i) - cell_position_x; % position relative to cell center
            position_y = yattach(i) - cell_position_y;
            new_x = position_x*cos(angular_displacement) - position_y*sin(angular_displacement);
            new_y = position_x*sin(angular_displacement) + position_y*cos(angular_displacement);
            xattach(i) = new_x + cell_position_x;
            yattach(i) = new_y + cell_position_y;
        end
    
    end
    
    % calculate the new forces for each cirrus
    for i=1:num_cirri
    
        if motionstate(i) == 0 % attached and not moving
            cirrus_length = sqrt((xpos(i) - xattach(i))^2 + (ypos(i) - yattach(i) )^2 );
            if cirrus_length > 0
            stretch_force = spring_constant*cirrus_length; %Hookes law
            unit_x = (xattach(i) - xpos(i))/cirrus_length; % unit vector in direction of the force
            unit_y = (yattach(i) - ypos(i))/cirrus_length;
            forceX(i) = stretch_force*unit_x; 
            forceY(i) = stretch_force*unit_y;
            else
                forceX(i) = 0;
                forceY(i) = 0;
            end
        else % moving and not attached
            % apply force towards the rear of the cell
            % note that the cirri exert a rear-ward force on the substrate
            % but the effect on the CELL is a forward force, i.e. the cell
            % is moved forwared by the reaction force from the substrate,
            % hence the force needs to be taken in the positive cell
            % direction!
            forceX(i) = cirrus_force*cos(cell_direction);
            forceY(i) = cirrus_force*sin(cell_direction);
        end
    
    end
    
    
    % check for motion state transitions
    for i=1:num_cirri

        if (motionstate(i) == 1) && (rand < P10) && legsToMoveVector(current_iteration) == i
            new_state = 0;
            last_transition(i) = current_iteration;
            xattach(i) = xpos(i); % attach to current position
            yattach(i) = ypos(i);
        elseif (motionstate(i) == 0) && (rand < P01) && legsToMoveVector(current_iteration) == i
            new_state = 1;
            last_transition(i) = current_iteration;
            xattach(i) = xpos(i); % detach and let substrate track cirrus base
            yattach(i) = ypos(i);
            release_spontaneous = release_spontaneous + 1;
        else
            new_state = motionstate(i);
        end
        motionstate(i) = new_state;

    end
   motionstate
        
        
    % check for detachment of cirri due to stretch
    % for i=1:num_cirri
    i = legsToMoveVector(current_iteration);
    if legsToMoveVector(current_iteration) == i
    
        cirrus_length = sqrt((xpos(i) - xattach(i))^2 + (ypos(i) - yattach(i) )^2 );
        if (motionstate(i) == 0) && (cirrus_length > detachment_length)
            motionstate(i) = 1;
            last_transition(i) = current_iteration;
            xattach(i) = xpos(i); 
            yattach(i) = ypos(i);
            release_pulling = release_pulling + 1;
        end
    
    end
 

end  % loop over all iterations

if verbose == 1
figure;
plot(cellxrecord,cellyrecord);
assignin('base','cellxrecord',cellxrecord);
assignin('base','cellyrecord',cellyrecord);
figure;
plot(1:iterations, directions);

figure;
plot(state_sum);
end

order_param = mean(motion_state_record(iterations));

if verbose == 1
fraction_induced_releases = release_pulling / (release_spontaneous + release_pulling)
end

if verbose == 1
    times_detached = total_detachments
    summed_displacements = total_motion
    distance_travelled = sqrt((cell_position_x-x_centroid)^2 + (cell_position_y-y_centroid)^2)
else
    times_detached = total_detachments;
    summed_displacements = total_motion;
    distance_travelled = sqrt((cell_position_x-x_centroid)^2 + (cell_position_y-y_centroid)^2);
end    
    
    
% two ways to describe distance travelled
% summed displacements adds up all the individual motion steps ignoring the
% sign or direction of the displacement
% distance travelled reports how far the cell got from its starting point
% by the end of the simulation

motion_state_record
b=order_param;
fclose(fid);