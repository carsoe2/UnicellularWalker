import math
import numpy as np

# Original coordinates
coordinates = [
    (384, 123),
    (333, 137),
    (353, 75),
    (303, 79),
    (265, 100),
    (328, 29),
    (303, 40),
    (223, 63),
    (195, 9),
    (143, 0),
    (87, 19),
    (53, 36),
    (0, 60),
    (51, 113)
]

# Calculate the original centroid
original_avg_x = sum(x for x, _ in coordinates) / len(coordinates)
original_avg_y = sum(y for _, y in coordinates) / len(coordinates)

'''
eta (float): Viscous drag coefficient.
spring_constant (float): Elastic constant of the cirri.
cirrus_force (float): Force generated by cirri.
detachment_length (float): Maximum length before a cirrus detaches.
'''
eta = 20
spring_constant = 2.0
cirrus_force = 1
detachment_length = 0.5

"""
Performs a single iteration of the noisy walker model.

Parameters:
    initial_leg_attach (list of tuples): (x, y) positions of where the end of each leg is located.
    leg_state (list): Motion states of legs (0 = attached, 1 = moving).
    action (int or None): Index of the leg to move or None if no action is taken.
    cell_state (tuple): (x, y, theta) of the cell.
    
Returns:
    new_attach (list of tuples): Updated (x, y) positions of the end ofeach leg.
    leg_state (list): Updated motion states of the legs.
    cell_state (tuple): Updated (x, y, theta) of the cell.
"""
def noisy_walker_v6(initial_leg_attach, leg_state, action, cell_state):
    initial_leg_pos = transform_coordinates(cell_state[0], cell_state[1], cell_state[2])
    num_legs = len(initial_leg_pos)
    xpos, ypos = zip(*initial_leg_pos)  # Extract x, y positions separately
    xpos, ypos = np.array(xpos), np.array(ypos)
    xattach, yattach = zip(*initial_leg_attach)
    xattach, yattach = np.array(xattach), np.array(yattach)
    forceX, forceY = [0]*14, [0]*14

    # Compute max distance (longest linear dimension of the cell)
    max_distance = max(np.sqrt((xpos[i] - xpos[j]) ** 2 + (ypos[i] - ypos[j]) ** 2) 
                       for i in range(num_legs) for j in range(num_legs))
    
    # Calculate forces for each cirrus
    for i in range(num_legs):
        if leg_state[i] == 0:  # Attached cirri
            cirrus_length = np.sqrt((xpos[i] - xattach[i]) ** 2 + (ypos[i] - yattach[i]) ** 2)
            if cirrus_length > 0:
                stretch_force = spring_constant * cirrus_length
                unit_x = (xattach[i] - xpos[i]) / cirrus_length
                unit_y = (yattach[i] - ypos[i]) / cirrus_length
                forceX[i] = stretch_force * unit_x
                forceY[i] = stretch_force * unit_y
            else:
                forceX[i] = 0
                forceY[i] = 0
        else:
            forceX[i] = cirrus_force * np.cos(cell_state[2])
            forceY[i] = cirrus_force * np.sin(cell_state[2])
    
    # Compute net force and torque
    force_sum_x, force_sum_y, torque_sum = 0, 0, 0
    for i in range(num_legs):
        force_sum_x += forceX[i]
        force_sum_y += forceY[i]
        position_vector_x, position_vector_y = xpos[i] - cell_state[0], ypos[i] - cell_state[1]
        torque_sum += position_vector_x * forceY[i] - position_vector_y * forceX[i]

    # Compute rigid-body translations
    displacement_x, displacement_y = force_sum_x / eta, force_sum_y / eta

    # Update leg positions
    xpos += displacement_x
    ypos += displacement_y
    for i in range(num_legs):
        if leg_state[i] == 1:  # Move detached cirri
            xattach[i] += displacement_x
            yattach[i] += displacement_y

    # Compute rigid-body rotation
    eta_rotation = 0.5 * eta * (max_distance ** 2)
    angular_displacement = torque_sum / eta_rotation
    theta = (cell_state[2] + angular_displacement) % (2 * np.pi)
    cell_state = (cell_state[0] + displacement_x, cell_state[1] + displacement_y, theta)

    # Apply rotation to cirri
    for i in range(num_legs):
        pos_x, pos_y = xpos[i] - cell_state[0], ypos[i] - cell_state[1]
        xpos[i] = cell_state[0] + (pos_x * np.cos(angular_displacement) - pos_y * np.sin(angular_displacement))
        ypos[i] = cell_state[1] + (pos_x * np.sin(angular_displacement) + pos_y * np.cos(angular_displacement))

        if leg_state[i] == 1:  # Apply rotation to substrate attachment points
            pos_x, pos_y = xattach[i] - cell_state[0], yattach[i] - cell_state[1]
            xattach[i] = cell_state[0] + (pos_x * np.cos(angular_displacement) - pos_y * np.sin(angular_displacement))
            yattach[i] = cell_state[1] + (pos_x * np.sin(angular_displacement) + pos_y * np.cos(angular_displacement))
    
    # Check for detachment due to excessive stretch
    detatched = []
    for i in range(num_legs):
        cirrus_length = np.linalg.norm([xpos[i] - xattach[i], ypos[i] - yattach[i]])
        if leg_state[i] == 0 and cirrus_length > detachment_length:
            detatched.append(i)
            leg_state[i] = 1
            xattach[i] = xpos[i]
            yattach[i] = ypos[i]
    
    if action is not None: #and action not in detatched:
        if leg_state[action] == 1:
            leg_state[action] = 0
            xattach[action] = xpos[action]
            yattach[action] = ypos[action]
        elif leg_state[action] == 0:
            leg_state[action] = 1
            xattach[action] = xpos[action]
            yattach[action] = ypos[action]

    new_attach = list(zip(xattach, yattach))

    return new_attach, leg_state, cell_state

def transform_coordinates(new_avg_x, new_avg_y, theta):
    # Rotate and translate each point
    transformed = []
    for x, y in coordinates:
        # Translate to origin
        x0 = x - original_avg_x
        y0 = y - original_avg_y
        
        # Rotate around origin
        x_rot = x0 * math.cos(theta) - y0 * math.sin(theta)
        y_rot = x0 * math.sin(theta) + y0 * math.cos(theta)
        
        # Translate to new average
        x_new = x_rot + new_avg_x
        y_new = y_rot + new_avg_y
        
        transformed.append((x_new, y_new))
    
    return transformed
